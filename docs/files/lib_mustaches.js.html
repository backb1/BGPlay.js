<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib\mustaches.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/BgpDataChecksView.html">BgpDataChecksView</a></li>
            
                <li><a href="..&#x2F;classes/Bgplay.html">Bgplay</a></li>
            
                <li><a href="..&#x2F;classes/Cluster.html">Cluster</a></li>
            
                <li><a href="..&#x2F;classes/ControllerQuerySimpleView.html">ControllerQuerySimpleView</a></li>
            
                <li><a href="..&#x2F;classes/ControllerView.html">ControllerView</a></li>
            
                <li><a href="..&#x2F;classes/Event.html">Event</a></li>
            
                <li><a href="..&#x2F;classes/GraphView.html">GraphView</a></li>
            
                <li><a href="..&#x2F;classes/InfoPanelView.html">InfoPanelView</a></li>
            
                <li><a href="..&#x2F;classes/Instant.html">Instant</a></li>
            
                <li><a href="..&#x2F;classes/JsonWrapGeneric.html">JsonWrapGeneric</a></li>
            
                <li><a href="..&#x2F;classes/JsonWrapRipestat.html">JsonWrapRipestat</a></li>
            
                <li><a href="..&#x2F;classes/JsonWrapTraceroutes.html">JsonWrapTraceroutes</a></li>
            
                <li><a href="..&#x2F;classes/LegendView.html">LegendView</a></li>
            
                <li><a href="..&#x2F;classes/MainView.html">MainView</a></li>
            
                <li><a href="..&#x2F;classes/Node.html">Node</a></li>
            
                <li><a href="..&#x2F;classes/NodePositionView.html">NodePositionView</a></li>
            
                <li><a href="..&#x2F;classes/NodeView.html">NodeView</a></li>
            
                <li><a href="..&#x2F;classes/OptionAnimationSpeedView.html">OptionAnimationSpeedView</a></li>
            
                <li><a href="..&#x2F;classes/OptionPopupView.html">OptionPopupView</a></li>
            
                <li><a href="..&#x2F;classes/Path.html">Path</a></li>
            
                <li><a href="..&#x2F;classes/PathView.html">PathView</a></li>
            
                <li><a href="..&#x2F;classes/Source.html">Source</a></li>
            
                <li><a href="..&#x2F;classes/Target.html">Target</a></li>
            
                <li><a href="..&#x2F;classes/TimelineView.html">TimelineView</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/model.html">model</a></li>
            
                <li><a href="..&#x2F;modules/modules.html">modules</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib\mustaches.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http:&#x2F;&#x2F;github.com&#x2F;janl&#x2F;mustache.js
 *&#x2F;

&#x2F;*global define: false*&#x2F;

(function (root, factory) {
    if (typeof exports === &quot;object&quot; &amp;&amp; exports) {
        module.exports = factory; &#x2F;&#x2F; CommonJS
    } else if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {
        define(factory); &#x2F;&#x2F; AMD
    } else {
        root.Mustache = factory; &#x2F;&#x2F; &lt;script&gt;
    }
}(this, (function () {

    var exports = {};

    exports.name = &quot;mustache.js&quot;;
    exports.version = &quot;0.7.2&quot;;
    exports.tags = [&quot;{{&quot;, &quot;}}&quot;];

    exports.Scanner = Scanner;
    exports.Context = Context;
    exports.Writer = Writer;

    var whiteRe = &#x2F;\s*&#x2F;;
    var spaceRe = &#x2F;\s+&#x2F;;
    var nonSpaceRe = &#x2F;\S&#x2F;;
    var eqRe = &#x2F;\s*=&#x2F;;
    var curlyRe = &#x2F;\s*\}&#x2F;;
    var tagRe = &#x2F;#|\^|\&#x2F;|&gt;|\{|&amp;|=|!&#x2F;;

    var _test = RegExp.prototype.test;
    var _toString = Object.prototype.toString;

    &#x2F;&#x2F; Workaround for https:&#x2F;&#x2F;issues.apache.org&#x2F;jira&#x2F;browse&#x2F;COUCHDB-577
    &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;janl&#x2F;mustache.js&#x2F;issues&#x2F;189
    function testRe(re, string) {
        return _test.call(re, string);
    }

    function isWhitespace(string) {
        return !testRe(nonSpaceRe, string);
    }

    var isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === &#x27;[object Array]&#x27;;
    };

    function escapeRe(string) {
        return string.replace(&#x2F;[\-\[\]{}()*+?.,\\\^$|#\s]&#x2F;g, &quot;\\$&amp;&quot;);
    }

    var entityMap = {
        &quot;&amp;&quot;: &quot;&amp;amp;&quot;,
        &quot;&lt;&quot;: &quot;&amp;lt;&quot;,
        &quot;&gt;&quot;: &quot;&amp;gt;&quot;,
        &#x27;&quot;&#x27;: &#x27;&amp;quot;&#x27;,
        &quot;&#x27;&quot;: &#x27;&amp;#39;&#x27;,
        &quot;&#x2F;&quot;: &#x27;&amp;#x2F;&#x27;
    };

    function escapeHtml(string) {
        return String(string).replace(&#x2F;[&amp;&lt;&gt;&quot;&#x27;\&#x2F;]&#x2F;g, function (s) {
            return entityMap[s];
        });
    }

    &#x2F;&#x2F; Export the escaping function so that the user may override it.
    &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;janl&#x2F;mustache.js&#x2F;issues&#x2F;244
    exports.escape = escapeHtml;

    function Scanner(string) {
        this.string = string;
        this.tail = string;
        this.pos = 0;
    }

    &#x2F;**
     * Returns &#x60;true&#x60; if the tail is empty (end of string).
     *&#x2F;
    Scanner.prototype.eos = function () {
        return this.tail === &quot;&quot;;
    };

    &#x2F;**
     * Tries to match the given regular expression at the current position.
     * Returns the matched text if it can match, the empty string otherwise.
     *&#x2F;
    Scanner.prototype.scan = function (re) {
        var match = this.tail.match(re);

        if (match &amp;&amp; match.index === 0) {
            this.tail = this.tail.substring(match[0].length);
            this.pos += match[0].length;
            return match[0];
        }

        return &quot;&quot;;
    };

    &#x2F;**
     * Skips all text until the given regular expression can be matched. Returns
     * the skipped string, which is the entire tail if no match can be made.
     *&#x2F;
    Scanner.prototype.scanUntil = function (re) {
        var match, pos = this.tail.search(re);

        switch (pos) {
            case -1:
                match = this.tail;
                this.pos += this.tail.length;
                this.tail = &quot;&quot;;
                break;
            case 0:
                match = &quot;&quot;;
                break;
            default:
                match = this.tail.substring(0, pos);
                this.tail = this.tail.substring(pos);
                this.pos += pos;
        }

        return match;
    };

    function Context(view, parent) {
        this.view = view;
        this.parent = parent;
        this._cache = {};
    }

    Context.make = function (view) {
        return (view instanceof Context) ? view : new Context(view);
    };

    Context.prototype.push = function (view) {
        return new Context(view, this);
    };

    Context.prototype.lookup = function (name) {
        var value = this._cache[name];

        if (!value) {
            if (name == &#x27;.&#x27;) {
                value = this.view;
            } else {
                var context = this;

                while (context) {
                    if (name.indexOf(&#x27;.&#x27;) &gt; 0) {
                        value = context.view;
                        var names = name.split(&#x27;.&#x27;), i = 0;
                        while (value &amp;&amp; i &lt; names.length) {
                            value = value[names[i++]];
                        }
                    } else {
                        value = context.view[name];
                    }

                    if (value != null) break;

                    context = context.parent;
                }
            }

            this._cache[name] = value;
        }

        if (typeof value === &#x27;function&#x27;) value = value.call(this.view);

        return value;
    };

    function Writer() {
        this.clearCache();
    }

    Writer.prototype.clearCache = function () {
        this._cache = {};
        this._partialCache = {};
    };

    Writer.prototype.compile = function (template, tags) {
        var fn = this._cache[template];

        if (!fn) {
            var tokens = exports.parse(template, tags);
            fn = this._cache[template] = this.compileTokens(tokens, template);
        }

        return fn;
    };

    Writer.prototype.compilePartial = function (name, template, tags) {
        var fn = this.compile(template, tags);
        this._partialCache[name] = fn;
        return fn;
    };

    Writer.prototype.getPartial = function (name) {
        if (!(name in this._partialCache) &amp;&amp; this._loadPartial) {
            this.compilePartial(name, this._loadPartial(name));
        }

        return this._partialCache[name];
    };

    Writer.prototype.compileTokens = function (tokens, template) {
        var self = this;
        return function (view, partials) {
            if (partials) {
                if (typeof partials === &#x27;function&#x27;) {
                    self._loadPartial = partials;
                } else {
                    for (var name in partials) {
                        self.compilePartial(name, partials[name]);
                    }
                }
            }

            return renderTokens(tokens, self, Context.make(view), template);
        };
    };

    Writer.prototype.render = function (template, view, partials) {
        return this.compile(template)(view, partials);
    };

    &#x2F;**
     * Low-level function that renders the given &#x60;tokens&#x60; using the given &#x60;writer&#x60;
     * and &#x60;context&#x60;. The &#x60;template&#x60; string is only needed for templates that use
     * higher-order sections to extract the portion of the original template that
     * was contained in that section.
     *&#x2F;
    function renderTokens(tokens, writer, context, template) {
        var buffer = &#x27;&#x27;;

        var token, tokenValue, value;
        for (var i = 0, len = tokens.length; i &lt; len; ++i) {
            token = tokens[i];
            tokenValue = token[1];

            switch (token[0]) {
                case &#x27;#&#x27;:
                    value = context.lookup(tokenValue);

                    if (typeof value === &#x27;object&#x27;) {
                        if (isArray(value)) {
                            for (var j = 0, jlen = value.length; j &lt; jlen; ++j) {
                                buffer += renderTokens(token[4], writer, context.push(value[j]), template);
                            }
                        } else if (value) {
                            buffer += renderTokens(token[4], writer, context.push(value), template);
                        }
                    } else if (typeof value === &#x27;function&#x27;) {
                        var text = template == null ? null : template.slice(token[3], token[5]);
                        value = value.call(context.view, text, function (template) {
                            return writer.render(template, context);
                        });
                        if (value != null) buffer += value;
                    } else if (value) {
                        buffer += renderTokens(token[4], writer, context, template);
                    }

                    break;
                case &#x27;^&#x27;:
                    value = context.lookup(tokenValue);

                    &#x2F;&#x2F; Use JavaScript&#x27;s definition of falsy. Include empty arrays.
                    &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;janl&#x2F;mustache.js&#x2F;issues&#x2F;186
                    if (!value || (isArray(value) &amp;&amp; value.length === 0)) {
                        buffer += renderTokens(token[4], writer, context, template);
                    }

                    break;
                case &#x27;&gt;&#x27;:
                    value = writer.getPartial(tokenValue);
                    if (typeof value === &#x27;function&#x27;) buffer += value(context);
                    break;
                case &#x27;&amp;&#x27;:
                    value = context.lookup(tokenValue);
                    if (value != null) buffer += value;
                    break;
                case &#x27;name&#x27;:
                    value = context.lookup(tokenValue);
                    if (value != null) buffer += exports.escape(value);
                    break;
                case &#x27;text&#x27;:
                    buffer += tokenValue;
                    break;
            }
        }

        return buffer;
    }

    &#x2F;**
     * Forms the given array of &#x60;tokens&#x60; into a nested tree structure where
     * tokens that represent a section have two additional items: 1) an array of
     * all tokens that appear in that section and 2) the index in the original
     * template that represents the end of that section.
     *&#x2F;
    function nestTokens(tokens) {
        var tree = [];
        var collector = tree;
        var sections = [];

        var token;
        for (var i = 0, len = tokens.length; i &lt; len; ++i) {
            token = tokens[i];
            switch (token[0]) {
                case &#x27;#&#x27;:
                case &#x27;^&#x27;:
                    sections.push(token);
                    collector.push(token);
                    collector = token[4] = [];
                    break;
                case &#x27;&#x2F;&#x27;:
                    var section = sections.pop();
                    section[5] = token[2];
                    collector = sections.length &gt; 0 ? sections[sections.length - 1][4] : tree;
                    break;
                default:
                    collector.push(token);
            }
        }

        return tree;
    }

    &#x2F;**
     * Combines the values of consecutive text tokens in the given &#x60;tokens&#x60; array
     * to a single token.
     *&#x2F;
    function squashTokens(tokens) {
        var squashedTokens = [];

        var token, lastToken;
        for (var i = 0, len = tokens.length; i &lt; len; ++i) {
            token = tokens[i];
            if (token) {
                if (token[0] === &#x27;text&#x27; &amp;&amp; lastToken &amp;&amp; lastToken[0] === &#x27;text&#x27;) {
                    lastToken[1] += token[1];
                    lastToken[3] = token[3];
                } else {
                    lastToken = token;
                    squashedTokens.push(token);
                }
            }
        }

        return squashedTokens;
    }

    function escapeTags(tags) {
        return [
            new RegExp(escapeRe(tags[0]) + &quot;\\s*&quot;),
            new RegExp(&quot;\\s*&quot; + escapeRe(tags[1]))
        ];
    }

    &#x2F;**
     * Breaks up the given &#x60;template&#x60; string into a tree of token objects. If
     * &#x60;tags&#x60; is given here it must be an array with two string values: the
     * opening and closing tags used in the template (e.g. [&quot;&lt;%&quot;, &quot;%&gt;&quot;]). Of
     * course, the default is to use mustaches (i.e. Mustache.tags).
     *&#x2F;
    exports.parse = function (template, tags) {
        template = template || &#x27;&#x27;;
        tags = tags || exports.tags;

        if (typeof tags === &#x27;string&#x27;) tags = tags.split(spaceRe);
        if (tags.length !== 2) throw new Error(&#x27;Invalid tags: &#x27; + tags.join(&#x27;, &#x27;));

        var tagRes = escapeTags(tags);
        var scanner = new Scanner(template);

        var sections = [];     &#x2F;&#x2F; Stack to hold section tokens
        var tokens = [];       &#x2F;&#x2F; Buffer to hold the tokens
        var spaces = [];       &#x2F;&#x2F; Indices of whitespace tokens on the current line
        var hasTag = false;    &#x2F;&#x2F; Is there a {{tag}} on the current line?
        var nonSpace = false;  &#x2F;&#x2F; Is there a non-space char on the current line?

        &#x2F;&#x2F; Strips all whitespace tokens array for the current line
        &#x2F;&#x2F; if there was a {{#tag}} on it and otherwise only space.
        function stripSpace() {
            if (hasTag &amp;&amp; !nonSpace) {
                while (spaces.length) {
                    delete tokens[spaces.pop()];
                }
            } else {
                spaces = [];
            }

            hasTag = false;
            nonSpace = false;
        }

        var start, type, value, chr, token;
        while (!scanner.eos()) {
            start = scanner.pos;

            &#x2F;&#x2F; Match any text between tags.
            value = scanner.scanUntil(tagRes[0]);
            if (value) {
                for (var i = 0, len = value.length; i &lt; len; ++i) {
                    chr = value.charAt(i);

                    if (isWhitespace(chr)) {
                        spaces.push(tokens.length);
                    } else {
                        nonSpace = true;
                    }

                    tokens.push([&#x27;text&#x27;, chr, start, start + 1]);
                    start += 1;

                    &#x2F;&#x2F; Check for whitespace on the current line.
                    if (chr == &#x27;\n&#x27;) stripSpace();
                }
            }

            &#x2F;&#x2F; Match the opening tag.
            if (!scanner.scan(tagRes[0])) break;
            hasTag = true;

            &#x2F;&#x2F; Get the tag type.
            type = scanner.scan(tagRe) || &#x27;name&#x27;;
            scanner.scan(whiteRe);

            &#x2F;&#x2F; Get the tag value.
            if (type === &#x27;=&#x27;) {
                value = scanner.scanUntil(eqRe);
                scanner.scan(eqRe);
                scanner.scanUntil(tagRes[1]);
            } else if (type === &#x27;{&#x27;) {
                value = scanner.scanUntil(new RegExp(&#x27;\\s*&#x27; + escapeRe(&#x27;}&#x27; + tags[1])));
                scanner.scan(curlyRe);
                scanner.scanUntil(tagRes[1]);
                type = &#x27;&amp;&#x27;;
            } else {
                value = scanner.scanUntil(tagRes[1]);
            }

            &#x2F;&#x2F; Match the closing tag.
            if (!scanner.scan(tagRes[1])) throw new Error(&#x27;Unclosed tag at &#x27; + scanner.pos);

            token = [type, value, start, scanner.pos];
            tokens.push(token);

            if (type === &#x27;#&#x27; || type === &#x27;^&#x27;) {
                sections.push(token);
            } else if (type === &#x27;&#x2F;&#x27;) {
                &#x2F;&#x2F; Check section nesting.
                if (sections.length === 0) throw new Error(&#x27;Unopened section &quot;&#x27; + value + &#x27;&quot; at &#x27; + start);
                var openSection = sections.pop();
                if (openSection[1] !== value) throw new Error(&#x27;Unclosed section &quot;&#x27; + openSection[1] + &#x27;&quot; at &#x27; + start);
            } else if (type === &#x27;name&#x27; || type === &#x27;{&#x27; || type === &#x27;&amp;&#x27;) {
                nonSpace = true;
            } else if (type === &#x27;=&#x27;) {
                &#x2F;&#x2F; Set the tags for the next time around.
                tags = value.split(spaceRe);
                if (tags.length !== 2) throw new Error(&#x27;Invalid tags at &#x27; + start + &#x27;: &#x27; + tags.join(&#x27;, &#x27;));
                tagRes = escapeTags(tags);
            }
        }

        &#x2F;&#x2F; Make sure there are no open sections when we&#x27;re done.
        var openSection = sections.pop();
        if (openSection) throw new Error(&#x27;Unclosed section &quot;&#x27; + openSection[1] + &#x27;&quot; at &#x27; + scanner.pos);

        tokens = squashTokens(tokens);

        return nestTokens(tokens);
    };

    &#x2F;&#x2F; All Mustache.* functions use this writer.
    var _writer = new Writer();

    &#x2F;**
     * Clears all cached templates and partials in the default writer.
     *&#x2F;
    exports.clearCache = function () {
        return _writer.clearCache();
    };

    &#x2F;**
     * Compiles the given &#x60;template&#x60; to a reusable function using the default
     * writer.
     *&#x2F;
    exports.compile = function (template, tags) {
        return _writer.compile(template, tags);
    };

    &#x2F;**
     * Compiles the partial with the given &#x60;name&#x60; and &#x60;template&#x60; to a reusable
     * function using the default writer.
     *&#x2F;
    exports.compilePartial = function (name, template, tags) {
        return _writer.compilePartial(name, template, tags);
    };

    &#x2F;**
     * Compiles the given array of tokens (the output of a parse) to a reusable
     * function using the default writer.
     *&#x2F;
    exports.compileTokens = function (tokens, template) {
        return _writer.compileTokens(tokens, template);
    };

    &#x2F;**
     * Renders the &#x60;template&#x60; with the given &#x60;view&#x60; and &#x60;partials&#x60; using the
     * default writer.
     *&#x2F;
    exports.render = function (template, view, partials) {
        return _writer.render(template, view, partials);
    };

    &#x2F;&#x2F; This is here for backwards compatibility with 0.4.x.
    exports.to_html = function (template, view, partials, send) {
        var result = exports.render(template, view, partials);

        if (typeof send === &quot;function&quot;) {
            send(result);
        } else {
            return result;
        }
    };

    return exports;

}())));
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
